---
title: "Human Population Size on an Earth-like Planet--a Computer Experiment"
authors: "Justin Patterson, Elsa Beda"
output: pdf_document
---

```{r}
library("dplyr")
library("MaxPro")
```

```{r}
DATA_PATH = file.path("/home/justin/Documents/schoolwork/ISYE_6413_Design_of_Exp/doe_group_project/data")
```


```{r}
#####################################################
# Functions
#####################################################
scale_from_0_1 = function(x, rescalings) {
    # Given a matrix x of real numbers,
    # rescale the entries.  Assume that
    # entries in the same column of x
    # should be rescaled in the same way.
    #
    # Args:
    #   x: numeric. matrix with entries in the
    #       interval [0, 1].
    #   rescalings: matrix. It is required that
    #       NROW(rescalings) == NCOL(x).  Each row of 
    #       rescalings should contain a vector
    #       with two entries. The 1st entry
    #       should be the min and the 2nd entry
    #       should be the max for the rescaling
    #       of the column in x corresponding to 
    #       that row.
    #   
    # Returns:
    #   matrix of the same dimensions as x.
    num_x_rows = NROW(x)
    num_x_cols = NCOL(x)
    # To be filled in later . . . .
    rescaled_x = matrix(
        data = numeric(length = num_x_rows * num_x_cols), 
        nrow = num_x_rows, 
        ncol = num_x_cols, 
        byrow = TRUE
    )
    
    # Rescale each column of x.
    for (j in seq_len(num_x_cols)) {
        rescaled_x[, j] = x[, j]*(rescalings[j, 2] - rescalings[j, 1]) + rescalings[j, 1]
    }

    return(rescaled_x)
}

scale_to_0_1 = function(x, rescalings) {
    # Given a matrix x of real numbers,
    # rescale the entries.  Assume that
    # entries in the same column of x
    # should be rescaled in the same way.
    #
    # Args:
    #   x: numeric. matrix.
    #   rescalings: matrix. It is required that
    #       NROW(rescalings) == NCOL(x).  Each row of 
    #       rescalings should contain a vector
    #       with two entries. The 1st entry
    #       should be the min and the 2nd entry
    #       should be the max for the rescaling
    #       of the column in x corresponding to 
    #       that row.
    #   
    # Returns:
    #   matrix of the same dimensions as x.
    num_x_rows = NROW(x)
    num_x_cols = NCOL(x)
    # To be filled in later . . . .
    rescaled_x = matrix(
        data = numeric(length = num_x_rows * num_x_cols), 
        nrow = num_x_rows, 
        ncol = num_x_cols, 
        byrow = TRUE
    )
    
    # Rescale each column of x.
    for (j in seq_len(num_x_cols)) {
        rescaled_x[, j] = (x[, j] - rescalings[j, 1])/(rescalings[j, 2] - rescalings[j, 1])
    }

    return(rescaled_x)
}

# Don't forget to update this as necessary
# as the constraints are hard-coded.
is_valid_treatment_for_ecoregion = function(treatment){ 
    # Initialize everything as TRUE,
    # assuming that everything is going to be valid.
    is_the_trt_valid = rep(TRUE, length(treatment))

    is_the_trt_valid[1] = (treatment[1] >= 1.5*max(treatment[2], treatment[3]))
    is_the_trt_valid[5] = (round(treatment[5], 10) != 0)
    return(all(is_the_trt_valid))
}

is_valid_treatment_for_realm = function(treatment){ 
    # Initialize everything as TRUE,
    # assuming that everything is going to be valid.
    is_the_trt_valid = rep(TRUE, length(treatment))

    return(all(is_the_trt_valid))
}

is_valid_treatment_for_realm_biome_combo = function(treatment){ 
    # Initialize everything as TRUE,
    # assuming that everything is going to be valid.
    is_the_trt_valid = rep(TRUE, length(treatment))

    return(all(is_the_trt_valid))
}

generate_max_pro_design = function(n, p_cont, rescalings, is_valid_treatment) {
    # Generate a MaxPro design with n design points
    # in the space [0, 1]^{p_cont}.
    #
    # Args:
    #   n: numeric(1).
    #   p_cont: numeric(1).
    #   rescalings: matrix. It is required that
    #       NROW(rescalings) == p_cont.  Each row of 
    #       rescalings should contain a vector
    #       with two entries. The 1st entry
    #       should be the min and the 2nd entry
    #       should be the max for the rescaling
    #       of the factor corresponding to 
    #       that row.
    #   is_valid_treatment: function. 
    #
    # Returns:
    #   matrix of scaled design 

    # The authors of MaxPro recommend that the initial design 
    # used in the MaxPro fucntion is generated by the 
    # MaxProLHD function.
    d_obj = MaxPro::MaxProLHD(
        n = n,
        p = p_cont,
        s = 2,
        itermax = 350,
        total_iter = 1e+03
    )

    d = d_obj[["Design"]]

    # Improve the design further.
    print("Running MaxPro . . . .")
    d_obj = MaxPro::MaxPro(
        InitialDesign = d,
        s = 2,
        iteration = 3
    )

    d = d_obj[["Design"]]

    # Rescale design to check constraints.
    d = scale_from_0_1(
        x = d,
        rescalings = rescalings
    )

    # Check constraints.
    valid_runs = apply(
        X = d,
        MARGIN = 1,
        FUN = is_valid_treatment
    )

    # Subset design to only retrieve valid runs.
    d = d[valid_runs, ]

    # Rescale back to 0-1
    d = scale_to_0_1(
        x = d,
        rescalings = rescalings
    )

    # Generate a candidate design meeting the constraints
    # that we can pull from.
    c = CandPoints(N = 10000, p_cont = p_cont)

    # Make sure the candidate design meets the constraints.
    # Scale and re-scale to filter.
    c = scale_from_0_1(
        x = c,
        rescalings = rescalings
    )

    valid_runs = apply(
        X = c,
        MARGIN = 1,
        FUN = is_valid_treatment
    )

    c = scale_to_0_1(
        x = c,
        rescalings = rescalings
    )

    c = c[valid_runs, ]

    # Calculate the number of new points needed.
    new_needed = n - NROW(d)
    if (new_needed > 0) {
        # Get more points
        print("Running MaxProAugment . . .")
        d_obj = MaxProAugment(
            ExistDesign = d, 
            CandDesign = c, 
            nNew = new_needed
        )

        d = d_obj[["Design"]]
    }

    # Scale
    d = scale_from_0_1(
        x = d,
        rescalings = rescalings
    )

    # Check constraints again just to be sure.
    print("Are all constraints met?")
    print(
        all(
            apply(
                X = d,
                MARGIN = 1,
                FUN = is_valid_treatment
            )
        ) 
    )

    return(d)
}

get_design_for_earth = function(design_helper) {
    # Generate a MaxPro
    # design for an earth.
    #
    # Args:
    #   design_helper: list. 
    #
    # Returns:
    #   dataframe. The returned value
    #       is the planning matrix.

    # Loop through the process for each kind of experimental unit.
    # Each time, get a design and add it to our list.
    num_kinds_of_exp_units = NROW(design_helper[["num_factors"]])
    designs = vector(mode = "list", length = num_kinds_of_exp_units)

    for (i in seq_along(designs)) {
        exp_unit = design_helper[["num_factors"]][i, "experimental_unit", drop = TRUE]
        num_factors = design_helper[["num_factors"]][i, "num_factors", drop = TRUE]

        designs[[i]] = generate_max_pro_design(
            n = length(design_helper[["num_repeats_needed"]][[exp_unit]]),
            p_cont = num_factors,
            rescalings = design_helper[["rescalings"]][[exp_unit]],
            is_valid_treatment = design_helper[["is_valid_treatment"]][[exp_unit]]
        ) %>%
            repeat_rows(
                times = design_helper[["num_repeats_needed"]][[exp_unit]]
            )
    }
}

repeat_rows = function(x, times) {
    # Repeat rows of a matrix x.
    # 
    # Args:
    #   x: matrix. 
    #   times: numeric vector. Each entry
    #       specifies how many times to 
    #       repeat the corresponding row.
    #       It should be true that
    #       length(times) == NROW(x).
    # 
    # Returns:   
    #   matrix  

    stopifnot(length(times) == NROW(x)) 
    # Initialize
    num_rows = sum(times)
    num_cols = NCOL(x)
    repeated_x = matrix(
        data = numeric(length = num_rows * num_cols),
        nrow = num_rows,
        ncol = num_cols
    )
    row_repeats_used = 0
    # Duplicate rows in x and save the result into repeated_x.
    # Loop through rows of x.
    for (i in seq_along(times)) {
        row_repeats_needed = times[i]
        if (row_repeats_needed == 0){
            # There were no repeats needed for this row of x.
            next
        }
        repeated_x[row_repeats_used + seq.int(row_repeats_needed), ] = x[
            rep(i, times = row_repeats_needed), 
            # all cols
        ]
        row_repeats_used = row_repeats_used + row_repeats_needed 
    }
    return(repeated_x)
}
```

Read in the factor chart showing the split-plot design and factor constraints.

```{r}
factor_chart = read.csv(
    file = file.path(DATA_PATH, "factor_chart.tsv"),
    header = TRUE,
    sep = "\t"
)

nestings = read.csv(
    file = file.path(DATA_PATH, "ecos.tsv"),
    header = TRUE,
    sep = "\t"
)

num_factors = factor_chart %>% 
    group_by(experimental_unit) %>% 
    summarize(num_factors = n())

# For each kind of experimental unit,
# extract the sub-matrix of rescalings.
# Store these sub-matrices in a list.
# https://dplyr.tidyverse.org/articles/programming.html
rescalings = vector(mode = "list", length = NROW(num_factors))
names(rescalings) = num_factors[["experimental_unit"]]
# How many times does each experimental unit
# get repeated for the experimental unit
# with the lowest granularity (i.e. locations)?
# This will be a vector for each experimental unit.
# Also store this in a list.
num_repeats_needed = vector(mode = "list", length = NROW(num_factors))
names(num_repeats_needed) = num_factors[["experimental_unit"]]
for (i in seq_len(NROW(num_factors))) {
    exp_unit = num_factors[i, 1, drop = TRUE]
    rescalings[[i]] = factor_chart %>%
        dplyr::filter(experimental_unit == exp_unit) %>%
        dplyr::select(min_level, max_level)

    if (exp_unit == "realm/biome combo") {
        num_repeats_needed[[i]] = nestings %>%
            dplyr::group_by(REALM, BIOME_NAME) %>%
            dplyr::summarize(n = n()) %>%
            dplyr::select(n) %>%
            dplyr::pull()
    } else if (exp_unit == "realm") {
        num_repeats_needed[[i]] = nestings %>%
            dplyr::group_by(REALM) %>%
            dplyr::summarize(n = n()) %>%
            dplyr::select(n) %>%
            dplyr::pull()
    } else if (exp_unit == "ecoregion") {
        num_repeats_needed[[i]] = nestings %>%
            dplyr::group_by(ECO_NAME) %>%
            dplyr::summarize(n = n()) %>%
            dplyr::select(n) %>%
            dplyr::pull()
    } else {
        print("Experimental unit not found.")
    }
}
    
design_helper = list(
    num_factors = num_factors,
    rescalings = rescalings,
    num_repeats_needed = num_repeats_needed,
    is_valid_treatment = list(
        realm = is_valid_treatment_for_realm,
        `realm/biome combo` = is_valid_treatment_for_realm_biome_combo,
        ecoregion = is_valid_treatment_for_ecoregion
    )
)
```

```{r}
num_factors_for_realms = sum(factor_chart["experimental_unit"] == "realm")
num_factors_for_realm_biome_combos = sum(factor_chart["experimental_unit"] == "biome/realm combo")
num_factors_for_ecoregions = sum(factor_chart["experimental_unit"] == "ecoregion")
```

```{r}
num_realms = NROW(unique(nestings["REALM"]))
num_biomes = NROW(unique(nestings["BIOME_NAME"]))
num_realm_biome_combos = NROW(unique(nestings[, c("REALM", "BIOME_NAME")]))
num_ecoregions = NROW(unique(nestings["ECO_NAME"]))
num_locations = NROW(nestings)

realm_counts = nestings %>% count(REALM)
realm_biome_combos_counts = nestings %>% count(REALM, BIOME_NAME)
biome_counts = nestings %>% count(BIOME_NAME)
ecoregion_counts = nestings %>% count(ECO_NAME)
```

Generate separate designs for each type of factor and then combine them.

```{r}
design_for_ecoregions = generate_max_pro_design(
    n = num_ecoregions,
    p_cont = num_factors_for_ecoregions,
    rescalings = factor_chart %>%
        dplyr::filter(experimental_unit == "ecoregion") %>%
        dplyr::select(min_level, max_level),
    is_valid_treatment = is_valid_treatment_for_ecoregion
) %>%
    repeat_rows(
        times = ecoregion_counts[["n"]]
    )
```

```{r}
design_for_realms = generate_max_pro_design(
    n = num_realms,
    p_cont = num_factors_for_realms,
    rescalings = factor_chart %>%
        dplyr::filter(experimental_unit == "realm") %>%
        dplyr::select(min_level, max_level),
    is_valid_treatment = is_valid_treatment_for_realm
) %>%
    repeat_rows(
        times = realm_counts[["n"]]
    )
```

```{r}
design_for_realm_biome_combos = generate_max_pro_design(
    n = num_realm_biome_combos,
    p_cont = num_factors_for_realm_biome_combos,
    rescalings = factor_chart %>%
        dplyr::filter(experimental_unit == "biome/realm combo") %>%
        dplyr::select(min_level, max_level),
    is_valid_treatment = is_valid_treatment_for_realm_biome_combo
) %>%
    repeat_rows(
        times = realm_biome_combos_counts[["n"]]
    )
```

```{r}
# Combine into one design
d = cbind(
    design_for_realms,
    design_for_realm_biome_combos,
    design_for_ecoregions
)

# Make a planning matrix and write to disk.
planning_matrix = data.frame(

)
```



```{r}
# Get day of the week.
cmd = "date"
my_field = 1
system2(cmd, args = paste0(' | cut -f ', my_field, ' -d " "'))
```

```{r}
system2(
    command = "python", 
    args = "-V", 
    stdout = TRUE,
    stderr = FALSE
)
```