---
title: "What is a good response?"
authors: "Justin Patterson, Elsa Beda"
output: pdf_document
---

```{r}
library("ggplot2")
```

```{r}
# Higher values indicate more reproducible.
REPRODUCIBILITIES_OF_FACTOR_SETTINGS_ON_POP = seq(0.1, 0.9, 0.2)
NUM_YEARS = 200
NUM_REPLICATES = 3
t = seq_len(NUM_YEARS)
starting_pop_size = c(100)
mean_growth_rate = c(1.03, 1.01)
combos_of_trts_and_repro_levels = expand.grid(
        mean_growth_rate = mean_growth_rate, 
        starting_pop_size = starting_pop_size
        # reproducibility_level = REPRODUCIBILITIES_OF_FACTOR_SETTINGS_ON_POP
    )

num_treatments = NROW(combos_of_trts_and_repro_levels)
combos_of_trts_and_repro_levels = cbind(
    data.frame(treatment = seq_len(num_treatments)),
    combos_of_trts_and_repro_levels
)

combos_of_trts_and_repro_levels = combos_of_trts_and_repro_levels[
    rep(
        seq_len(
            NROW(combos_of_trts_and_repro_levels)
        ), 
        each = length(REPRODUCIBILITIES_OF_FACTOR_SETTINGS_ON_POP)
    ), 
    # Leave blank to select all of the columns.

]

combos_of_trts_and_repro_levels[, "reproducibility_level"] = rep(
    REPRODUCIBILITIES_OF_FACTOR_SETTINGS_ON_POP, 
    times = num_treatments
)

combos_of_trts_and_repro_levels = combos_of_trts_and_repro_levels[
    rep(seq_len(NROW(combos_of_trts_and_repro_levels)), each = NUM_REPLICATES),
    # all cols
]

combos_of_trts_and_repro_levels[, "replicate"] = rep(
    seq_len(NUM_REPLICATES),
    times = NROW(combos_of_trts_and_repro_levels) / NUM_REPLICATES
)
# Initialize before loop
# https://stackoverflow.com/a/55836886/8423001
num_rows = NROW(combos_of_trts_and_repro_levels) * NUM_YEARS
num_cols = NCOL(combos_of_trts_and_repro_levels) + 2
pop_sizes = matrix(
    data = numeric(length = num_rows*num_cols), 
    nrow = num_rows, 
    ncol = num_cols,
    byrow = FALSE,
    dimnames = list(NULL, c(colnames(combos_of_trts_and_repro_levels), "year", "population_size"))
)

pop_sizes[, seq_len(NCOL(combos_of_trts_and_repro_levels))] = as.matrix(
    combos_of_trts_and_repro_levels[
        rep(
            seq_len(
                NROW(combos_of_trts_and_repro_levels)
            ),
            each = NUM_YEARS
        ),
        # Leave this blank to select all of the columns.
        , drop = TRUE
    ]
)

pop_sizes[, "year"] = rep(t, times = NROW(combos_of_trts_and_repro_levels))

# For each factor setting, 
# for each reproducibility level, generate a different set of 
# replicate growth curves.
# First set of errors
sd1 = (1 / pop_sizes[, "reproducibility_level"]) * 0.0001
e1 = (0.05 + (-0.05 / NUM_YEARS) * pop_sizes[, "year"]) + rnorm(n=NROW(pop_sizes), mean = 0, sd = sd1)
# e1 = rep(0, NROW(pop_sizes))
# Second set of errors
sd2 = log(pop_sizes[, "year"]) / pop_sizes[, "reproducibility_level"] 
# e2 = round(rnorm(n = NROW(pop_sizes), mean = log(pop_sizes[, "year"]), sd = sd2))
e2 = rep(0, NROW(pop_sizes))
# Get starting pop. sizes copied over.
pop_sizes[pop_sizes[, "year"] == 1, "population_size"] = pop_sizes[
    pop_sizes[, "year"] == 1, "starting_pop_size"
] 

for (i in seq(2, NROW(pop_sizes))) {  
    current_pop_size = round(
        pop_sizes[i - 1, "population_size"] * (pop_sizes[i - 1, "mean_growth_rate"] + e1[i - 1])
    ) + e2[i - 1]

    # Handle extinctions
    # Did an extinction occur?
    if (current_pop_size <= 0) {
        # An extinction occurred.
        # Set the current and following population sizes to 0.
        # Use row_indices_to_keep for indexing into
        # logical vector of wanted rows.
        current_treatment = pop_sizes[i - 1, "treatment"]
        current_reproducibility_level = pop_sizes[i - 1, "reproducibility_level"]
        row_indices_to_change = which(
            (pop_sizes[ , "treatment"] == current_treatment) 
            & (pop_sizes[, "reproducibility_level"] == current_reproducibility_level)
        )
        pop_sizes[
            # Set the current and following population sizes to 0.
            row_indices_to_change[row_indices_to_change >= i], 
            "population_size"
        ] = 0
        
        break
    } else {
        pop_sizes[i, "population_size"] = current_pop_size
    }

}
```

```{r}
get_exp_data_with_error = function(max_t, b_0, b_1, b_2, e_0_extremeness, e_1_extremeness, e_2_extremeness) {
    # The model is y = (b_0 + e_0) + (b_1 + e_1)*exp((b_2 + e_2)*t)
    # where e_0, e_1 and e_2 are errors.
    # e_0_extremeness, e_1_extremeness & e_2_extremeness should be non-negative
    # with higher values indicating more extremeness.
    #
    # Returns y values.
    
    # R is 1-indexed. :(
    y = vector(mode = "numeric", length = max_t + 1)
    
    # It's some proportion of b_0
    sd_0 = e_0_extremeness * abs(b_0)
    e_0 = rnorm(n = max_t + 1, mean = 0, sd = sd_0)

    # Start large and decrease.
    # The part with (- e_1_extremeness * abs(b_1) / max_t)
    # is like the slope.
    sd_1 = e_1_extremeness * abs(b_1) + (- e_1_extremeness * abs(b_1) / max_t) * seq(0, max_t, 1)
    e_1 = rnorm(n = max_t + 1, mean = 0, sd = sd_1)

    sd_2 = e_2_extremeness * abs(b_2)
    e_2 = rnorm(n = max_t + 1, mean = 0, sd = sd_2)

    # y[1] means the y-value when t == 0.
    y[1] = round(b_0 + e_0[1] + b_1 + e_1[1])
    for (t in seq(2, max_t + 1, 1)) {
        y[t] = round((b_0 + e_0[t]) + (y[t - 1] - (b_0 + e_0[t]))*exp(b_2 + e_2[t]))
    }

    return(y)
}
```

```{r}
drop_cols_with_negs = function(X) {
    # Args:
    #   X: matrix
    # Returns:
    #   matrix with positive entries by
    #   dropping columns from X
    return(X[ , -(which(X <= 0, arr.ind = TRUE)[ , 2])])
}
```

```{r}
get_growth_data = function(
    num_replicates_1,
    num_replicates_2,
    max_t, 
    b_0, 
    b_1, 
    b_2,
    e_0_extremeness,
    e_1_extremeness, 
    e_2_extremeness
) {
    # Call get_exp_data_with_error.
    g = replicate(
        n = num_replicates_1,
        expr = replicate(
            n = num_replicates_2,
            expr = get_exp_data_with_error(
                max_t = max_t, 
                b_0 = b_0, 
                b_1 = b_1, 
                b_2 = b_2,
                e_0_extremeness = e_0_extremeness,
                e_1_extremeness = e_1_extremeness, 
                e_2_extremeness = e_2_extremeness
            )
        )
    )
    # Check for extinctions.
    # Before loop
    for (my_rep in seq_len(num_replicates_1)) {
        col_to_check = 1
        num_cols_in_g_rep = NCOL(g[ , , my_rep])
        while (col_to_check <= num_cols_in_g_rep) {
            # Check the current col.
            if (sum(g[, col_to_check, my_rep] <= 0) > 0) {
                # Extinction occurred. Update col.
                print("Extinction occurred.")
                # remove column
                g[ , , my_rep] = g[ , -col_to_check, my_rep]
                # There is no need to update col_to_check
                num_cols_in_g_rep = num_cols_in_g_rep - 1
            } else {
                # Update col_to_check
                col_to_check = col_to_check + 1
            }
        }
    }
    
    return(g)
}
```

```{r}
max_t = 100
NUM_REPLICATES_1 = 3
NUM_REPLICATES_2 = 30

# Args for function call
num_replicates_1 = NUM_REPLICATES_1
num_replicates_2 = NUM_REPLICATES_2
b_0 = 500
b_1 = 100
b_2 = 0.09
e_0_extremeness = 2
e_1_extremeness = 2
e_2_extremeness = 2

try_1 = get_growth_data(
    num_replicates_1 = NUM_REPLICATES_1,
    num_replicates_2 = NUM_REPLICATES_2,
    max_t = max_t, 
    b_0 = b_0, 
    b_1 = b_1, 
    b_2 = b_2,
    e_0_extremeness = e_0_extremeness,
    e_1_extremeness = e_1_extremeness, 
    e_2_extremeness = e_2_extremeness
)
```

```{r}

NUM_REPLICATES_2 = 1000
g = replicate(
    n = NUM_REPLICATES_2,
    expr = replicate(
        n = NUM_REPLICATES_1,
        expr = get_exp_data_with_error(
            max_t = max_t, 
            b_0 = 500, 
            b_1 = 100, 
            b_2 = 0.09,
            e_0_extremeness = 0.1,
            e_1_extremeness = 0.1, 
            e_2_extremeness = 0.1
        )
    )
)


```

```{r}
get_sum_var_logs = function(X) {
    # X: matrix
    #
    # The values in X are transformed via the log
    # function.  Next, the sample variances of the values
    # in each column of X are computed.
    # The sum of these variances is returned.
    return(sum(apply(X = log(X), MARGIN = 1, FUN = var)))
}
```

```{r}
get_sum_var_logs(g)
```


```{r}
g_data = data.frame(
    replicate_num = rep(seq_len(NCOL(g)), each = NROW(g)),
    year = rep(seq(0, NROW(g) - 1), times = NCOL(g)),
    log_pop_size = log(as.vector(g))
)
```

```{r}
fig = ggplot(
    data = g_data,
    mapping = aes(
        x = year,
        y = log_pop_size,
        color = as.factor(replicate_num)
    )
) 

fig = fig + geom_line()
fig
```



```{r}
plot(x = seq(0, max_t, 1), y = log(g), type = "l")
```

```{r}
# Calculate RMSDIQR for each set of replicates.
fig = ggplot(
    data = data.frame(pop_sizes[pop_sizes[, "treatment"] == 2, ]),
    # data = data.frame(pop_sizes),
    mapping = aes(
        x = year,
        y = population_size,
        color = as.factor(reproducibility_level)
        
    )
) 

fig = fig + geom_line(aes(group = replicate))
fig
```